/*
 * Copyright (c) 2016 Shanghai Jiao Tong University.
 *     All rights reserved.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS
 *  IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 *  express or implied.  See the License for the specific language
 *  governing permissions and limitations under the License.
 *
 * For more about this software visit:
 *
 *      http://ipads.se.sjtu.edu.cn/projects/wukong
 *
 */

#pragma once

#include <set>
#include <vector>
#include <cstring>
#include <string>

#include <boost/archive/binary_oarchive.hpp>
#include <boost/archive/binary_iarchive.hpp>
#include <boost/serialization/string.hpp>
#include <boost/serialization/vector.hpp>
#include <boost/serialization/set.hpp>
#include <boost/serialization/variant.hpp>
#include <boost/serialization/split_free.hpp>

#include "core/common/errors.hpp"
#include "core/common/type.hpp"

#include "core/store/vertex.hpp"

// utils
#include "utils/logger2.hpp"

namespace wukong {

using namespace boost::archive;

// defined as constexpr due to switch-case
constexpr int const_pair(int t1, int t2) { return ((t1 << 4) | t2); }

enum vstat { KNOWN_VAR = 0, UNKNOWN_VAR, CONST_VAR }; // variable stat

// EXT = [ TYPE:16 | COL:16 ]
#define NBITS_TYPE 16   // column type
#define NBITS_COL  16   // column number

// Init COL value with NO_RESULT
#define NO_RESULT  ((1 << NBITS_COL) - 1)


// conversion between col and ext
int col2ext(int col, int t) { return ((t << NBITS_COL) | col); }
int ext2col(int ext) { return (ext & ((1 << NBITS_COL) - 1)); }
int ext2type(int ext) { return ((ext >> NBITS_COL) & ((1 << NBITS_COL) - 1)); }

/**
 * SPARQL Query
 */
class SPARQLQuery {
private:
    friend class boost::serialization::access;

public:
    enum SQState { SQ_PATTERN = 0, SQ_UNION, SQ_FILTER, SQ_OPTIONAL, SQ_FINAL, SQ_REPLY };

    /*
     * Indicating where is this query's patterngroup from.
     * If this query is generated by generate_union_query, then PGType is UNION.
     * If this query is generated by generate_optional_query, then PGType is OPTIONAL.
     * The PGType of queries forked from BASIC is BASIC.
     * The PGType of queries forked from UNION is BASIC.
     * The PGType of queries forked from OPTIONAL is OPTIONAL.
     */
    enum PGType { BASIC, UNION, OPTIONAL };

    /**
     * Indicating what device will be used to handle the query.
     */
    enum DeviceType { CPU, GPU };

    enum SubJobType { FULL_JOB, SPLIT_JOB };

    enum TimeIntervalType { UNDEFINED, VALUE_VALUE, VALUE_VAR, VAR_VAR, VAR_VALUE };

#ifdef TRDF_MODE
    class TimeIntervalPattern {
    private:
        friend class boost::serialization::access;
        template <typename Archive>
        void serialize(Archive &ar, const unsigned int version) {
            ar & ts_value;
            ar & te_value;
            ar & ts_var;
            ar & te_var;
            ar & type;
        }
    public:
        // const
        int64_t ts_value;
        int64_t te_value;

        // unknown
        ssid_t ts_var;
        ssid_t te_var;

        TimeIntervalType type;

        TimeIntervalPattern() : type(UNDEFINED) {}

        TimeIntervalPattern(int64_t ts_value, int64_t te_value, ssid_t ts_var, ssid_t te_var):
            ts_value(ts_value), te_value(te_value), ts_var(ts_var), te_var(te_var) { 
            if(ts_value != 0 && te_value != 0) {
                type = VALUE_VALUE;
            } else if(ts_var != 0 && te_var != 0) {
                type = VAR_VAR;
            } else if(ts_value != 0 && te_var != 0) {
                type = VALUE_VAR;
            } else if(ts_var != 0 && te_value != 0) {
                type = VAR_VALUE;
            } else { type = UNDEFINED; }
        }
    };
#endif

    class Pattern {
    private:
        friend class boost::serialization::access;

    public:
        ssid_t subject;
        ssid_t predicate;
        ssid_t object;
        dir_t direction;

    #ifdef TRDF_MODE
        TimeIntervalPattern time_interval;
    #endif

        char pred_type = (char)SID_t;

        Pattern() { }

        Pattern(ssid_t subject, ssid_t predicate, dir_t direction, ssid_t object):
            subject(subject), predicate(predicate), object(object), direction(direction) { }

        Pattern(ssid_t subject, ssid_t predicate, ssid_t direction, ssid_t object):
            subject(subject), predicate(predicate), object(object), direction((dir_t)direction) { }

        void print_pattern() { }
    };

    class Filter {
    private:
        friend class boost::serialization::access;
        template <typename Archive>
        void serialize(Archive &ar, const unsigned int version) {
            ar & type;
            ar & arg1;
            ar & arg2;
            ar & arg3;
            ar & value;
            ar & valueArg;
        }

    public:
        enum Type {Or, And, Equal, NotEqual, Less, LessOrEqual, Greater, GreaterOrEqual,
                   Plus, Minus, Mul, Div, Not, UnaryPlus, UnaryMinus,
                   Literal, Variable, IRI, Function, ArgumentList, Builtin_str,
                   Builtin_lang, Builtin_langmatches, Builtin_datatype, Builtin_bound,
                   Builtin_sameterm, Builtin_isiri, Builtin_isblank, Builtin_isliteral,
                   Builtin_regex, Builtin_in
                  };

        Type type;
        Filter *arg1, *arg2, *arg3; /// Input arguments
        std::string value; /// The value (for constants param)
        int valueArg; /// variable ids

        /// Constructor
        Filter() : arg1(0), arg2(0), arg3(0), valueArg(0) { }

        /// Copy-Constructor
        Filter(const Filter &other)
            : type(other.type), arg1(0), arg2(0), arg3(0),
              value(other.value), valueArg(other.valueArg) {
            if (other.arg1)
                arg1 = new Filter(*other.arg1);
            if (other.arg2)
                arg2 = new Filter(*other.arg2);
            if (other.arg3)
                arg3 = new Filter(*other.arg3);
        }

        /// Destructor
        ~Filter() {
            delete arg1;
            delete arg2;
            delete arg3;
        }

        void print_filter() const {
            // print info type | value | valueArg
            logstream(LOG_INFO) << "\t" << this->type << "\t" << valueArg;
            if (this->value != "")
                logstream(LOG_INFO) << "\t" << this->value << LOG_endl;
            else
                logstream(LOG_INFO) << "\t" << "--" << LOG_endl;

            if (arg1 != NULL) arg1->print_filter();
            if (arg2 != NULL) arg2->print_filter();
            if (arg3 != NULL) arg3->print_filter();
        }
    };

    class PatternGroup {
    private:
        friend class boost::serialization::access;

    public:
        std::vector<Pattern> patterns;
        std::vector<PatternGroup> unions;
        std::vector<Filter> filters;
        std::vector<PatternGroup> optional;

        // new vars appeared in this OPTIONAL PG. This PG is from the vector optional
        std::set<ssid_t> optional_new_vars;

        void print_group() const {
            logstream(LOG_INFO) << "patterns[" << patterns.size() << "]:" << LOG_endl;
            for (auto const &p : patterns)
                logstream(LOG_INFO) << "\t" << p.subject
                                    << "\t" << p.predicate
                                    << "\t" << p.direction
                                    << "\t" << p.object << LOG_endl;

            logstream(LOG_INFO) << "unions[" << unions.size() << "]:" << LOG_endl;
            for (auto const &g : unions)
                g.print_group();

            logstream(LOG_INFO) << "optionals[" << optional.size() << "]:" << LOG_endl;
            for (auto const &g : optional)
                g.print_group();

            logstream(LOG_INFO) << "filters[" << filters.size() << "]:" << LOG_endl;
            logstream(LOG_INFO) << "\ttype"
                                << "\tvalueArg"
                                << "\tvalue" << LOG_endl;
            for (auto const &f : filters)
                f.print_filter();
        }

        // used to calculate dst_sid
        ssid_t get_start() {
            if (this->patterns.size() > 0)
                return this->patterns[0].subject;
            else if (this->unions.size() > 0)
                return this->unions[0].get_start();
            else if (this->optional.size() > 0)
                return this->optional[0].get_start();
            else
                ASSERT_ERROR_CODE(false, UNKNOWN_PATTERN);
            return BLANK_ID;
        }
    };

    class Order {
    private:
        friend class boost::serialization::access;
        template <typename Archive>
        void serialize(Archive &ar, const unsigned int version) {
            ar & id;
            ar & descending;
        }

    public:
        ssid_t id;  /// variable id
        bool descending;    /// desending

        Order() { }

        Order(ssid_t _id, bool _descending)
            : id(_id), descending(_descending) { }
    };

    class Result {
    private:
        friend class boost::serialization::access;

#ifdef USE_GPU
        // intermediate result generated on GPU
        class GPUResult {
        private:
            char *result_buf_dp = nullptr;
            uint64_t result_buf_nelems = 0;
            int col_num = 0;    // copy of parent state

        public:
            char *rbuf() {
                return result_buf_dp;
            }

            uint64_t rbuf_num_elems() const {
                return result_buf_nelems;
            }

            bool is_rbuf_valid() const {
                return result_buf_dp != nullptr;
            }

            bool is_rbuf_empty() const {
                return (result_buf_dp == nullptr || result_buf_nelems == 0);
            }

            void clear_rbuf() {
                result_buf_dp = nullptr;
                result_buf_nelems = 0;
            }

            void set_rbuf(char *rbuf, uint64_t n) {
                ASSERT(rbuf != nullptr);
                result_buf_dp = rbuf;
                result_buf_nelems = n;
            }

            int get_row_num() const {
                ASSERT(true == is_rbuf_valid());
                if (col_num == 0)
                    return 0;

                return result_buf_nelems / col_num;
            }

            void set_col_num(int c) {
                col_num = c;
            }

            template <typename Archive>
            void serialize(Archive &ar, const unsigned int version) {
                ar & result_buf_nelems;
                ar & col_num;
            }
        };
#endif


    public:
        Result() { }

        // metadata
        int col_num = 0;  // NOTE: use set_col_num() for modification
        int row_num = 0;  // FIXME: vs. get_row_num()
        int attr_col_num = 0; // FIXME: why not no attr_row_num
        int status_code = SUCCESS;

    #ifdef TRDF_MODE
        // time-related metadata
        int time_col_num = 0;

        // result table for timestamps
        std::vector<int64_t> time_res_table;
    #endif

        bool blind = false;
        int nvars = 0; // the number of variables
        std::vector<ssid_t> required_vars; // variables selected to return
        std::vector<int> v2c_map; // from variable ID (vid) to column ID, index: vid, value: col

        // OPTIONAL
        std::vector<bool> optional_matched_rows; // rows matched in optional block

        // data
        std::vector<sid_t> result_table; // result table for string IDs
        std::vector<attr_t> attr_res_table; // result table for others

#ifdef USE_GPU
        GPUResult gpu;
#endif

        void clear() {
            result_table.clear();
            attr_res_table.clear();
            required_vars.clear();
        #ifdef TRDF_MODE
            time_res_table.clear();
        #endif
        }

        vstat var_stat(ssid_t vid) {
            if (vid >= 0)
                return CONST_VAR;
            else if (var2col(vid) == NO_RESULT)
                return UNKNOWN_VAR;
            else
                return KNOWN_VAR;
        }

        /// mapping from variable ID (var) to column ID (col)
        /// var <=> idx <=> ext <=> col
        /// var <=> idx: var is set as -1,-2,...; idx (the index number of v2c_map) = - (vid + 1)
        /// idx <=> ext: ext store the col and type (attr_res_table or result_table); ext = v2c_map[idx]
        /// ext <=> col: ext2col and col2ext

        // get column id from vid (pattern variable)
        int var2col(ssid_t vid) {
            // number variables from -1 and decrease by 1 for each of rest. (i.e., -1, -2, ...)
            ASSERT_ERROR_CODE(vid < 0, VERTEX_INVALID);

            // the number of variables is known before calling var2col()
            ASSERT(nvars > 0);
            if (v2c_map.size() == 0)
                v2c_map.resize(nvars, NO_RESULT); // init

            // calculate idx
            int idx = - (vid + 1);
            ASSERT_ERROR_CODE(idx < nvars && idx >= 0, VERTEX_INVALID);

            // get col
            return ext2col(v2c_map[idx]);
        }

        // add column id to vid (pattern variable)
        void add_var2col(ssid_t vid, int col, int t = SID_t) {
            // number variables from -1 and decrease by 1 for each of rest. (i.e., -1, -2, ...)
            ASSERT(vid < 0 && col >= 0);

            // the number of variables is known before calling var2col()
            ASSERT(nvars > 0);
            if (v2c_map.size() == 0)
                v2c_map.resize(nvars, NO_RESULT); // init

            // calculate idx
            int idx = - (vid + 1);
            ASSERT(idx < nvars && idx >= 0);

            // variable should not be set
            ASSERT(v2c_map[idx] == NO_RESULT);
            v2c_map[idx] = col2ext(col, t);
        }

        // judge the column id belong to attribute result table or not

        data_type var_type(ssid_t vid) {
            // number variables from -1 and decrease by 1 for each of rest. (i.e., -1, -2, ...)
            ASSERT(vid < 0);

            // the number of variables is known before calling var2col()
            ASSERT(nvars > 0);
            if (v2c_map.size() == 0) // init
                v2c_map.resize(nvars, NO_RESULT);

            // calculate idx
            int idx = - (vid + 1);
            ASSERT(idx < nvars);

            // get type
            return (data_type) ext2type(v2c_map[idx]);
        }


        // NORMAL result (i.e., sid)
        void set_col_num(int n) {
            col_num = n;
#ifdef USE_GPU
            gpu.set_col_num(col_num); // FIXME: should be avoided
#endif
        }

        int get_col_num() const { return col_num; }

        int get_row_num() const {
            return (col_num == 0) ?
                   0 : (result_table.size() / col_num);
        }

        void update_nrows() {
            row_num = (col_num == 0) ?
                      0 : (result_table.size() / col_num);
        }

        sid_t get_row_col(int r, int c) {
            ASSERT(r >= 0 && c >= 0);
            return result_table[col_num * r + c];
        }

        void append_row_to(int r, std::vector<sid_t> &update) {
            for (int c = 0; c < col_num; c++)
                update.push_back(get_row_col(r, c));
        }

        void dup_rows(std::vector<sid_t> &update){
            result_table.assign(update.begin(), update.end());
        }

    #ifdef TRDF_MODE
        // TIMT_T result (i.e., timestamp)
        void set_time_col_num(int n) {
            time_col_num = n;
        }

        int get_time_col_num() const { return time_col_num; }

        sid_t get_time_row_col(int r, int c) {
            ASSERT(r >= 0 && c >= 0);
            return time_res_table[time_col_num * r + c];
        }

        void append_time_row_to(int r, std::vector<int64_t> &update) {
            for (int c = 0; c < time_col_num; c++)
                update.push_back(get_time_row_col(r, c));
        }

        void dup_time_rows(std::vector<int64_t> &update){
            time_res_table.assign(update.begin(), update.end());
        }
    #endif

        // ATTRIBUTE result (i.e., integer, float, and double)
        void set_attr_col_num(int n) { attr_col_num = n; }

        int get_attr_col_num() { return attr_col_num; }

        void set_status_code(int code) {
            status_code = code;
        }
        int get_status_code() { return status_code; }

        int get_attr_row_num() {
            return (attr_col_num == 0) ?
                   0 : (attr_res_table.size() / attr_col_num);
        }

        attr_t get_attr_row_col(int r, int c) {
            ASSERT(r >= 0 && c >= 0);
            return attr_res_table[attr_col_num * r + c];
        }

        void append_attr_row_to(int r, std::vector<attr_t> &updated_result_table) {
            for (int c = 0; c < attr_col_num; c++)
                updated_result_table.push_back(get_attr_row_col(r, c));
        }

        void dup_attr_rows(std::vector<attr_t> &update) {
            attr_res_table.assign(update.begin(), update.end());
        }


        // UNION
        // append a blank col to result table without updating col_num and v2c_map
        void append_blank_col(int col) {
            std::vector<sid_t> new_table;
            for (int i = 0; i < get_row_num(); i++) {
                new_table.insert(new_table.end(),
                                 result_table.begin() + (i * col_num),
                                 result_table.begin() + (i * col_num + col));
                new_table.push_back(BLANK_ID);
                new_table.insert(new_table.end(),
                                 result_table.begin() + (i * col_num + col),
                                 result_table.begin() + ((i + 1) * col_num));
            }

            result_table.swap(new_table);
        }

    #ifdef TRDF_MODE
        // UNION
        // append a blank col to time result table without updating time_col_num and v2c_map
        void append_blank_time_col(int col) {
            std::vector<int64_t> new_table;
            for (int i = 0; i < get_row_num(); i++) {
                new_table.insert(new_table.end(),
                                 time_res_table.begin() + (i * time_col_num),
                                 time_res_table.begin() + (i * time_col_num + col));
                new_table.push_back(TIMESTAMP_MAX);
                new_table.insert(new_table.end(),
                                 time_res_table.begin() + (i * time_col_num + col),
                                 time_res_table.begin() + ((i + 1) * time_col_num));
            }

            time_res_table.swap(new_table);
        }
    #endif

        // For UNION queries, merge two result table into one
        void merge_result(SPARQLQuery::Result &r) {
            /// update metadata (i.e., v2c_map, ncols, and nrows)
            nvars = r.nvars;
            v2c_map.resize(r.nvars, NO_RESULT);
            std::vector<int> col_map(r.nvars, -1);  // idx: my_col, value: your_col
        #ifdef TRDF_MODE
            std::vector<int> time_col_map(r.nvars, -1);  // idx: my_col, value: your_col
        #endif
            for (int i = 0; i < r.v2c_map.size(); i++) {
                ssid_t vid = - (i + 1);
                data_type type = r.var_type(vid);
            #ifdef TRDF_MODE
                if(type == TIME_t) {
                    if (v2c_map[i] == NO_RESULT && r.v2c_map[i] != NO_RESULT) {
                        append_blank_time_col(time_col_num);

                        add_var2col(vid, time_col_num, TIME_t);
                        time_col_map[time_col_num] = r.var2col(vid);
                        time_col_num++;
                    } else if (v2c_map[i] != NO_RESULT && r.v2c_map[i] == NO_RESULT) {
                        time_col_map[var2col(vid)] = -1;
                    } else if (v2c_map[i] != NO_RESULT && r.v2c_map[i] != NO_RESULT) {
                        time_col_map[var2col(vid)] = r.var2col(vid);
                    }
                    continue;
                }
            #endif
                if (v2c_map[i] == NO_RESULT && r.v2c_map[i] != NO_RESULT) {
                    append_blank_col(col_num);

                    add_var2col(vid, col_num);
                    col_map[col_num] = r.var2col(vid);
                    col_num++;
                } else if (v2c_map[i] != NO_RESULT && r.v2c_map[i] == NO_RESULT) {
                    col_map[var2col(vid)] = -1;
                } else if (v2c_map[i] != NO_RESULT && r.v2c_map[i] != NO_RESULT) {
                    col_map[var2col(vid)] = r.var2col(vid);
                }
            }
            row_num += r.row_num;

            // skip data
            if (r.blind) return;

            /// aggregate data (i.e., result table and attribute result table)
            result_table.reserve(col_num * row_num);
            for (int i = 0; i < r.row_num; i++) {
                for (int j = 0; j < col_num; j++) {
                    if (col_map[j] == -1)
                        result_table.push_back(BLANK_ID);
                    else
                        result_table.push_back(r.result_table[i * r.col_num + col_map[j]]);
                }
            }

        #ifdef TRDF_MODE
            time_res_table.reserve(time_col_num * row_num);
            for (int i = 0; i < r.row_num; i++) {
                for (int j = 0; j < time_col_num; j++) {
                    if (time_col_map[j] == -1)
                        time_res_table.push_back(TIMESTAMP_MAX);
                    else
                        time_res_table.push_back(r.time_res_table[i * r.time_col_num + time_col_map[j]]);
                }
            }
        #endif

            // update attribute result table
            ASSERT_ERROR_CODE(r.attr_col_num == 0, UNSUPPORT_UNION);
        }

        void append_result(SPARQLQuery::Result &r) {
            /// update metadata (i.e., v2c_map, ncols, attr_ncols, and nrows)
            // NOTE: all sub-jobs have the same v2c_map, ncols, and attr_ncols
            v2c_map = r.v2c_map;
            col_num = r.col_num;
        #ifdef TRDF_MODE
            time_col_num = r.time_col_num;
        #endif
            attr_col_num = r.attr_col_num;
            row_num += r.row_num; // add rows

            // skip data
            if (r.blind) return;

            /// aggregate data (i.e., result table and attribute result table)
            ASSERT((col_num * row_num) == (result_table.size() + r.result_table.size()));
            result_table.insert(result_table.end(),
                                r.result_table.begin(),
                                r.result_table.end());

        #ifdef TRDF_MODE
            ASSERT((time_col_num * row_num) == (time_res_table.size() + r.time_res_table.size()));
            time_res_table.insert(time_res_table.end(),
                                r.time_res_table.begin(),
                                r.time_res_table.end());
        #endif

            ASSERT((attr_col_num * row_num) == (attr_res_table.size() + r.attr_res_table.size()));
            attr_res_table.insert(attr_res_table.end(),
                                  r.attr_res_table.begin(),
                                  r.attr_res_table.end());
        }
    };

    int qid = -1;   // query id (track engine (sid, tid))
    int pqid = -1;  // parent qid (track the source (proxy or parent query) of query)

    PGType pg_type = BASIC;
    SQState state = SQ_PATTERN;

    DeviceType dev_type = CPU;
    SubJobType job_type = FULL_JOB;

#ifdef TRDF_MODE
    int64_t ts = TIMESTAMP_MIN; // start timestamp after keyword FROM
    int64_t te = TIMESTAMP_MAX; // end timestamp after keyword FROM
#endif

    int priority = 0;

    int mt_factor = 1;  // use a single engine (thread) by default
    int mt_tid = 0;     // engine thread number (MT)

    // Pattern
    int pattern_step = 0;
    ssid_t local_var = 0;   // the local variable
    bool corun_enabled = false;
    int corun_step = 0;
    int fetch_step = 0;

    // UNION
    bool union_done = false;

    // OPTIONAL
    int optional_step = 0;

    int limit = -1;
    unsigned offset = 0;
    bool distinct = false;

    // PatternGroup
    PatternGroup pattern_group;
    std::vector<Order> orders;
    Result result;

    SPARQLQuery() { }

    // build a query by existing query template
    SPARQLQuery(PatternGroup g, int nvars, std::vector<ssid_t> &required_vars)
        : pattern_group(g) {
        result.nvars = nvars;
        result.required_vars = required_vars;
        result.v2c_map.resize(nvars, NO_RESULT);
    }

    // return the current pattern
    Pattern & get_pattern() {
        ASSERT(pattern_step < pattern_group.patterns.size());
        return pattern_group.patterns[pattern_step];
    }

    // return a specific pattern
    Pattern & get_pattern(int step) {
        ASSERT(step < pattern_group.patterns.size());
        return pattern_group.patterns[step];
    }

    // shrink the query to reduce communication cost (before sending)
    void shrink() {
        pattern_group.patterns.clear();
        pattern_group.filters.clear();
        pattern_group.optional.clear();
        pattern_group.unions.clear();

        orders.clear();

        // discard results if does not care
        if (result.blind)
            result.clear(); // clear data but reserve metadata (e.g., #rows, #cols)
    }

    bool has_pattern() { return pattern_group.patterns.size() > 0; }

    bool has_union() { return pattern_group.unions.size() > 0; }

    bool has_optional() { return pattern_group.optional.size() > 0; }

    bool has_filter() { return pattern_group.filters.size() > 0; }

    bool done(SQState state) {
        switch (state) {
        case SQ_PATTERN:
            return (pattern_step >= pattern_group.patterns.size());
        case SQ_UNION:
            return union_done;
        case SQ_FILTER:
            // FIXME: DEAD CODE currently
            ASSERT(false);
        case SQ_OPTIONAL:
            return (optional_step >= pattern_group.optional.size());
        case SQ_FINAL:
            // FIXME: DEAD CODE currently
            ASSERT(false);
        case SQ_REPLY:
            // FIXME: DEAD CODE currently
            ASSERT(false);
        }
    }

    bool start_from_index() const {
        /*
         * Wukong assumes that its planner will generate a dummy pattern to hint
         * the query should start from a certain index (i.e., predicate or type).
         * For example: ?X __PREDICATE__  ub:undergraduateDegreeFrom
         *
         * NOTE: the graph exploration does not must start from this index,
         * on the contrary, starts from another index would prune bindings MORE efficiently
         * For example, ?X P0 ?Y, ?X P1 ?Z, ...
         *
         * ?X __PREDICATE__ P1 <- // start from index vertex P1
         * ?X P0 ?Y .             // then from ?X's edge with P0
         *
         */
        if (pattern_group.patterns.size() == 0) return false;
        else if (is_tpid(pattern_group.patterns[0].subject)) {
            // When the subject is index, predicate must be TYPE or PREDICATE
            ASSERT_ERROR_CODE(pattern_group.patterns[0].predicate == PREDICATE_ID
                              || pattern_group.patterns[0].predicate == TYPE_ID, OBJ_ERROR);
            return true;
        }
        return false;
    }

    void print_sparql_query() {
        logstream(LOG_INFO) << "SPARQLQuery"
                            << "[ QID=" << qid << " | PQID=" << pqid << " | MT_TID=" << mt_tid << " ]"
                            << LOG_endl;
        pattern_group.print_group();
        /// TODO: print more fields
        logstream(LOG_INFO) << LOG_endl;
    }

    void print_SQState() {
        logstream(LOG_INFO) << "SPARQLQuery"
                            << "[ QID=" << qid << " | PQID=" << pqid << " | MT_TID=" << mt_tid << " ]";
        switch (state) {
        case SQState::SQ_PATTERN: logstream(LOG_INFO) << "\tSQ_PATTERN" << LOG_endl; break;
        case SQState::SQ_REPLY: logstream(LOG_INFO) << "\tSQ_REPLY" << LOG_endl; break;
        case SQState::SQ_UNION: logstream(LOG_INFO) << "\tSQ_UNION" << LOG_endl; break;
        case SQState::SQ_OPTIONAL: logstream(LOG_INFO) << "\tSQ_OPTIONAL" << LOG_endl; break;
        case SQState::SQ_FILTER: logstream(LOG_INFO) << "\tSQ_FILTER" << LOG_endl; break;
        case SQState::SQ_FINAL: logstream(LOG_INFO) << "\tSQ_FINAL" << LOG_endl; break;
        default: logstream(LOG_INFO) << "\tUNKNOWN_STATE" << LOG_endl;
        }
    }

    // UNION
    void inherit_union(SPARQLQuery &r, int idx) {
        pqid = r.qid;
        pg_type = SPARQLQuery::PGType::UNION;
        pattern_group = r.pattern_group.unions[idx];
        if (start_from_index()
                && (Global::mt_threshold * Global::num_servers > 1)) {
            mt_factor = r.mt_factor;
        }
        result = r.result;
    #ifdef TRDF_MODE
        ts = r.ts;
        te = r.te;
    #endif
        result.blind = false;
    }

    // OPTIONAL

    // currently only count BGPs in OPTIONAL
    // [invoke] inherit_optional()
    void count_optional_new_vars(Result &r) {
        for (Pattern &p : this->pattern_group.patterns) {
            if (p.subject < 0 && r.var2col(p.subject) == NO_RESULT)
                this->pattern_group.optional_new_vars.insert(p.subject);
            if (p.predicate < 0 && r.var2col(p.predicate) == NO_RESULT)
                this->pattern_group.optional_new_vars.insert(p.predicate);
            if (p.object < 0 && r.var2col(p.object) == NO_RESULT)
                this->pattern_group.optional_new_vars.insert(p.object);
        }
    }

    // restrict patterns first
    // restrict patterns: index_to_known, known_to_known, known_to_const, const_to_known
    // [invoke] inherit_optional()
    void reorder_optional_patterns(Result &r) {
        int size = this->pattern_group.patterns.size();
        std::vector<Pattern> updated_patterns;
        std::vector<Pattern> known_to_unknown_patterns;
        std::vector<Pattern> const_to_unknown_patterns;
        std::vector<Pattern> unknown_patterns;

        for (int i = 0; i < size; i++) {
            Pattern &pattern = this->pattern_group.patterns[i];
            ssid_t start = pattern.subject;
            ssid_t pid   = pattern.predicate;
            ssid_t end   = pattern.object;
            if (is_tpid(start)) {
                ASSERT(pid == PREDICATE_ID || pid == TYPE_ID);
                if (r.var2col(end) != NO_RESULT) // index_to_known
                    updated_patterns.push_back(pattern);
                else    // index_to_unknown
                    const_to_unknown_patterns.push_back(pattern);
            } else {
                switch (const_pair(r.var_stat(start), r.var_stat(end))) {
                case const_pair(CONST_VAR, KNOWN_VAR):
                case const_pair(KNOWN_VAR, CONST_VAR):
                case const_pair(KNOWN_VAR, KNOWN_VAR):
                    // const_to_known, known_to_const, known_to_known
                    updated_patterns.push_back(pattern);
                    break;
                case const_pair(CONST_VAR, UNKNOWN_VAR):
                    const_to_unknown_patterns.push_back(pattern);
                    break;
                case const_pair(KNOWN_VAR, UNKNOWN_VAR):
                    known_to_unknown_patterns.push_back(pattern);
                    break;
                default:
                    unknown_patterns.push_back(pattern);
                }
            }
        }

        updated_patterns.insert(updated_patterns.end(),
                                known_to_unknown_patterns.begin(),
                                known_to_unknown_patterns.end());
        updated_patterns.insert(updated_patterns.end(),
                                const_to_unknown_patterns.begin(),
                                const_to_unknown_patterns.end());
        updated_patterns.insert(updated_patterns.end(),
                                unknown_patterns.begin(),
                                unknown_patterns.end());

        this->pattern_group.patterns.swap(updated_patterns);
    }

    void inherit_optional(SPARQLQuery &r) {
        pqid = r.qid;
        pg_type = SPARQLQuery::PGType::OPTIONAL;
        pattern_group = r.pattern_group.optional[r.optional_step];

        if (start_from_index()
                && (Global::mt_threshold * Global::num_servers > 1))
            mt_factor = r.mt_factor;

        count_optional_new_vars(r.result);
        reorder_optional_patterns(r.result);
        result = r.result;
        result.optional_matched_rows = std::vector<bool>(r.result.get_row_num(), true);
        result.blind = false;
    }

    void correct_optional_result(int row) {
        std::set<ssid_t>::iterator iter;
        for (iter = this->pattern_group.optional_new_vars.begin();
                iter != this->pattern_group.optional_new_vars.end(); iter++) {
            int col = this->result.var2col(*iter);
            if (col != NO_RESULT)
                this->result.result_table[row * this->result.col_num + col] = BLANK_ID;
        }
    }
};


/**
 * SPARQL query template
 */
class SPARQLQuery_Template {
private:
    // no serialize

public:
    SPARQLQuery::PatternGroup pattern_group;

    int nvars;  // the number of variable in triple patterns
    std::vector<ssid_t> required_vars; // variables selected to return

    std::vector<std::string> ptypes_str; // the Types of random-constants
    std::vector<int> ptypes_pos; // the locations of random-constants

    std::vector<std::vector<sid_t>> ptypes_grp; // the candidates for random-constants

    SPARQLQuery instantiate(int seed) {
        for (int i = 0; i < ptypes_pos.size(); i++) {
            int pos = ptypes_pos[i];
            switch (pos % 4) {
            case 0:
                pattern_group.patterns[pos / 4].subject =
                    ptypes_grp[i][seed % ptypes_grp[i].size()];
                break;
            case 1:
                pattern_group.patterns[pos / 4].predicate =
                    ptypes_grp[i][seed % ptypes_grp[i].size()];
                break;
            case 3:
                pattern_group.patterns[pos / 4].object =
                    ptypes_grp[i][seed % ptypes_grp[i].size()];
                break;
            }
        }

        return SPARQLQuery(pattern_group, nvars, required_vars);
    }
};


/**
 * GStore consistency checker
 */
class GStoreCheck {
private:
    friend class boost::serialization::access;

    template <typename Archive>
    void serialize(Archive &ar, const unsigned int version) {
        ar & qid;
        ar & pqid;
        ar & check_ret;
        ar & index_check;
        ar & normal_check;
    }

public:
    int qid = -1;   // unused
    int pqid = -1;  // parent qid

    int check_ret = 0;
    bool index_check = false;
    bool normal_check = false;

    GStoreCheck() { }

    GStoreCheck(bool i, bool n) : index_check(i), normal_check(n) { }
};

/**
 * RDF data loader
 */
class RDFLoad {
private:
    friend class boost::serialization::access;

    template <typename Archive>
    void serialize(Archive &ar, const unsigned int version) {
        ar & qid;
        ar & pqid;
        ar & load_dname;
        ar & load_ret;
        ar & check_dup;
    }

public:
    int qid = -1;   // unused
    int pqid = -1;  // parent query id

    std::string load_dname = "";   // the file name used to be inserted
    int load_ret = 0;
    bool check_dup = false;

    RDFLoad() { }

    RDFLoad(std::string s, bool b) : load_dname(s), check_dup(b) { }
};

} // namespace wukong

namespace boost {
namespace serialization {
char occupied = 0;
char empty = 1;

template<class Archive>
void save(Archive &ar, const wukong::SPARQLQuery::Pattern &t, unsigned int version) {
    ar << t.subject;
    ar << t.predicate;
    ar << t.object;
    ar << t.direction;
    ar << t.pred_type;
#ifdef TRDF_MODE
    ar << t.time_interval;
#endif
}

template<class Archive>
void load(Archive &ar, wukong::SPARQLQuery::Pattern &t, unsigned int version) {
    ar >> t.subject;
    ar >> t.predicate;
    ar >> t.object;
    ar >> t.direction;
    ar >> t.pred_type;
#ifdef TRDF_MODE
    ar >> t.time_interval;
#endif
}

template<class Archive>
void save(Archive &ar, const wukong::SPARQLQuery::PatternGroup &t, unsigned int version) {
    ar << t.patterns;
    ar << t.optional_new_vars;  // it should not be put into the "if (t.optional.size() > 0)" block. The PG itself is from optional
    if (t.filters.size() > 0) {
        ar << occupied;
        ar << t.filters;
    } else ar << empty;

    if (t.optional.size() > 0) {
        ar << occupied;
        ar << t.optional;
    } else ar << empty;

    if (t.unions.size() > 0) {
        ar << occupied;
        ar << t.unions;
    } else ar << empty;
}

template<class Archive>
void load(Archive &ar, wukong::SPARQLQuery::PatternGroup &t, unsigned int version) {
    char temp = 2;
    ar >> t.patterns;
    ar >> t.optional_new_vars;
    ar >> temp;
    if (temp == occupied) {
        ar >> t.filters;
        temp = 2;
    }
    ar >> temp;
    if (temp == occupied) {
        ar >> t.optional;
        temp = 2;
    }
    ar >> temp;
    if (temp == occupied) {
        ar >> t.unions;
        temp = 2;
    }
}

template<class Archive>
void save(Archive &ar, const wukong::SPARQLQuery::Result &t, unsigned int version) {
    ar << t.col_num;
    ar << t.row_num;
    ar << t.attr_col_num;
    ar << t.status_code;
    ar << t.blind;
    ar << t.nvars;
    ar << t.required_vars;
    ar << t.v2c_map;
    ar << t.optional_matched_rows;
    if (t.row_num > 0) {
        ar << occupied;
        ar << t.result_table;
        ar << t.attr_res_table;
    } else {
        ar << empty;
    }
#ifdef USE_GPU
    ar << t.gpu;
#endif
#ifdef TRDF_MODE
    ar << t.time_col_num;
    ar << t.time_res_table;
#endif
}

template<class Archive>
void load(Archive & ar, wukong::SPARQLQuery::Result &t, unsigned int version) {
    char temp = 2;
    ar >> t.col_num;
    ar >> t.row_num;
    ar >> t.attr_col_num;
    ar >> t.status_code;
    ar >> t.blind;
    ar >> t.nvars;
    ar >> t.required_vars;
    ar >> t.v2c_map;
    ar >> t.optional_matched_rows;
    ar >> temp;
    if (temp == occupied) {
        ar >> t.result_table;
        ar >> t.attr_res_table;
    }
#ifdef USE_GPU
    ar >> t.gpu;
#endif
#ifdef TRDF_MODE
    ar >> t.time_col_num;
    ar >> t.time_res_table;
#endif
}

template<class Archive>
void save(Archive & ar, const wukong::SPARQLQuery &t, unsigned int version) {
    ar << t.qid;
    ar << t.pqid;
    ar << t.pg_type;
    ar << t.state;
    ar << t.dev_type;
    ar << t.job_type;
    ar << t.priority;
    ar << t.mt_factor;
    ar << t.mt_tid;
    ar << t.pattern_step;
    ar << t.local_var;
    ar << t.corun_enabled;
    ar << t.corun_step;
    ar << t.fetch_step;
    ar << t.union_done;
    ar << t.optional_step;
    ar << t.limit;
    ar << t.offset;
    ar << t.distinct;
    ar << t.pattern_group;
#ifdef TRDF_MODE
    ar << t.ts;
    ar << t.te;
#endif
    if (t.orders.size() > 0) {
        ar << occupied;
        ar << t.orders;
    } else {
        ar << empty;
    }
    ar << t.result;
}

template<class Archive>
void load(Archive & ar, wukong::SPARQLQuery &t, unsigned int version) {
    char temp = 2;
    ar >> t.qid;
    ar >> t.pqid;
    ar >> t.pg_type;
    ar >> t.state;
    ar >> t.dev_type;
    ar >> t.job_type;
    ar >> t.priority;
    ar >> t.mt_factor;
    ar >> t.mt_tid;
    ar >> t.pattern_step;
    ar >> t.local_var;
    ar >> t.corun_enabled;
    ar >> t.corun_step;
    ar >> t.fetch_step;
    ar >> t.union_done;
    ar >> t.optional_step;
    ar >> t.limit;
    ar >> t.offset;
    ar >> t.distinct;
    ar >> t.pattern_group;
#ifdef TRDF_MODE
    ar >> t.ts;
    ar >> t.te;
#endif
    ar >> temp;
    if (temp == occupied) ar >> t.orders;
    ar >> t.result;
}

}
}

BOOST_SERIALIZATION_SPLIT_FREE(wukong::SPARQLQuery::Pattern);
BOOST_SERIALIZATION_SPLIT_FREE(wukong::SPARQLQuery::PatternGroup);
BOOST_SERIALIZATION_SPLIT_FREE(wukong::SPARQLQuery::Result);
BOOST_SERIALIZATION_SPLIT_FREE(wukong::SPARQLQuery);

// remove class information at the cost of losing auto versioning,
// which is useless currently because wukong use boost serialization to transmit data
// between endpoints running the same code.
BOOST_CLASS_IMPLEMENTATION(wukong::SPARQLQuery::Pattern, boost::serialization::object_serializable);
BOOST_CLASS_IMPLEMENTATION(wukong::SPARQLQuery::PatternGroup, boost::serialization::object_serializable);
BOOST_CLASS_IMPLEMENTATION(wukong::SPARQLQuery::Filter, boost::serialization::object_serializable);
BOOST_CLASS_IMPLEMENTATION(wukong::SPARQLQuery::Order, boost::serialization::object_serializable);
BOOST_CLASS_IMPLEMENTATION(wukong::SPARQLQuery::Result, boost::serialization::object_serializable);
BOOST_CLASS_IMPLEMENTATION(wukong::SPARQLQuery, boost::serialization::object_serializable);

BOOST_CLASS_IMPLEMENTATION(wukong::GStoreCheck, boost::serialization::object_serializable);
BOOST_CLASS_IMPLEMENTATION(wukong::RDFLoad, boost::serialization::object_serializable);

// remove object tracking information at the cost of that multiple identical objects
// may be created when an archive is loaded.
// current query data structure does not contain two identical object reference
// with the same pointer
BOOST_CLASS_TRACKING(wukong::SPARQLQuery::Pattern, boost::serialization::track_never);
BOOST_CLASS_TRACKING(wukong::SPARQLQuery::Filter, boost::serialization::track_never);
BOOST_CLASS_TRACKING(wukong::SPARQLQuery::PatternGroup, boost::serialization::track_never);
BOOST_CLASS_TRACKING(wukong::SPARQLQuery::Order, boost::serialization::track_never);
BOOST_CLASS_TRACKING(wukong::SPARQLQuery::Result, boost::serialization::track_never);
BOOST_CLASS_TRACKING(wukong::SPARQLQuery, boost::serialization::track_never);

BOOST_CLASS_TRACKING(wukong::GStoreCheck, boost::serialization::track_never);
BOOST_CLASS_TRACKING(wukong::RDFLoad, boost::serialization::track_never);

namespace wukong {

enum req_type { SPARQL_QUERY = 0, DYNAMIC_LOAD = 1, GSTORE_CHECK = 2, SPARQL_HISTORY = 3 };

/**
 * Bundle to be sent by network, with data type labeled
 * Note this class does not use boost serialization
 */
class Bundle {
private:
    friend class boost::serialization::access;
    template <typename Archive>
    void serialize(Archive &ar, const unsigned int version) {
        ar & type;
        ar & data;
    }

public:
    req_type type;
    std::string data;

    Bundle() { }

    Bundle(const req_type &t, const std::string &d): type(t), data(d) { }

    Bundle(const Bundle &b): type(b.type), data(b.data) { }

    Bundle(const SPARQLQuery &r): type(SPARQL_QUERY) {
        std::stringstream ss;
        boost::archive::binary_oarchive oa(ss);

        oa << r;
        data = ss.str();
    }

    Bundle(const RDFLoad &r): type(DYNAMIC_LOAD) {
        std::stringstream ss;
        boost::archive::binary_oarchive oa(ss);

        oa << r;
        data = ss.str();
    }

    Bundle(const GStoreCheck &r): type(GSTORE_CHECK) {
        std::stringstream ss;
        boost::archive::binary_oarchive oa(ss);

        oa << r;
        data = ss.str();
    }

    Bundle(const std::string str) { init(str); }

    void init(const std::string str) {
        memcpy(&type, str.c_str(), sizeof(req_type));
        std::string d(str, sizeof(req_type), str.length() - sizeof(req_type));
        data = d;
    }

    // SPARQLQuery command
    SPARQLQuery get_sparql_query() const {
        ASSERT(type == SPARQL_QUERY);

        std::stringstream ss;
        ss << data;

        boost::archive::binary_iarchive ia(ss);
        SPARQLQuery result;
        ia >> result;
        return result;
    }

    // RDFLoad command
    RDFLoad get_rdf_load() const {
        ASSERT(type == DYNAMIC_LOAD);

        std::stringstream ss;
        ss << data;

        boost::archive::binary_iarchive ia(ss);
        RDFLoad result;
        ia >> result;
        return result;
    }

    // GStoreCheck command
    GStoreCheck get_gstore_check() const {
        ASSERT(type == GSTORE_CHECK);

        std::stringstream ss;
        ss << data;

        boost::archive::binary_iarchive ia(ss);
        GStoreCheck result;
        ia >> result;
        return result;
    }

    std::string to_str() const {
#if 1 // FIXME
        char *c_str = new char[sizeof(req_type) + data.length()];
        memcpy(c_str, &type, sizeof(req_type));
        memcpy(c_str + sizeof(req_type), data.c_str(), data.length());
        std::string str(c_str, sizeof(req_type) + data.length());
        delete []c_str;
        return str;
#else
        // FIXME: why not work? (Rong)
        return std::string(std::to_string((uint64_t)type) + data);
#endif
    }

};

} // namespace wukong